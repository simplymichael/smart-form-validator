{"version":3,"file":"smart-form-validator.min.js","sources":["../src/error-messages.js","../src/helpers.js","../src/effects/effects-helpers.js","../src/effects/add-bottom-border/index.js","../src/effects/add-validation-status-icons/index.js","../src/effects/toggle-submit-button/index.js","../src/effects/index.js","../src/validators/validator-helpers.js","../src/validators/alphanumeric-validator.js","../src/validators/alpha-validator.js","../src/validators/ascii-text-validator.js","../src/validators/email-validator.js","../src/validators/length-validator.js","../src/validators/number-validator.js","../src/validators/regex-validator.js","../src/validators/index.js","../src/validators/required-field-validator.js","../src/smart-field.js","../src/methods/addField.js","../src/methods/addFields.js","../src/methods/addRule.js","../src/methods/addValidator.js","../src/methods/getEffects.js","../src/methods/getField.js","../src/methods/getFields.js","../src/methods/getValidators.js","../src/methods/removeRule.js","../src/methods/toJSON.js","../src/methods/useEffect.js","../src/methods/validate.js","../src/methods/watch.js","../src/methods/index.js","../src/smart-form.js","../src/smart-form-validator.js","../src/index.js"],"sourcesContent":["module.exports = {\n  argNamesAreReserved: \"The following :argNames: are reserved and cannot be used as :argTypes:: \\n:argValues:\",\n  fieldCannotBeEmpty: \"The `:field:` field expects a non-empty :type:\",\n  fieldNotRegistered: \"No field with the specified id (\\\":id:\\\") has been registered on this :element:\",\n  functionParamExpectsType: \"The `:param:` argument expects :type:\",\n  functionParamIsRequired: \"The `:param:` argument is required\",\n  htmlElementExpected: \"The `:param:` argument expects an HTML `:elementType:` element\",\n  noObjectWithSpecifiedKey: \"No :object: with the key `:key:` exists\",\n  noEffectsActive: \"There are no active effects set on this field. \\n\" +\n    \"You can set an effect by calling `useEffect(effect)`\",\n  noValidatorsActive: \"There are no active validators for this field. \" +\n    \"You can do one of the following to fix this issue: \" + \n    \"1. Re-enable any disabled validators by calling `enableValidator(key)` \\n\" + \n    \"2. Add a rule using the `addRule(rule)` method \\n\" +\n    \"3. Add a validator using the `addValidator(key, validator, meta)` method\",\n  objectPropertyCannotBeEmpty: \"The `:prop:` property of the `:object:` object cannot be empty\",\n  objectMustHaveProperty: \"The `:param:` argument must have a `:prop:` property\",\n  objectsMustHaveProperty: \"The `:paramA:` argument must have a `:propA:` property or The `:paramB:` argument must have a `:propB:` property\",\n  objectPropertyShouldHaveType: \"The `:prop:` property of the `:object:` object shoulde be :type:\",\n  objectWithKeyExists: \":object: with key `:key:` already exists\",\n  objectWithKeyExistsCanReplace: \":object: with key `:key:` already exists. Use `:replacer:` to replace it.\",\n  unknownType: \"Unknown :type:: `:typeName:`, allowed :types: are: :allowedTypes:\",\n};","\"use strict\";\n\nconst errorMessages = require(\"./error-messages\");\n\nconst APP_CLASSNAME = \"sfv\";\nconst SMART_FIELD_CLASSNAME = \"sfv-sf\";\nconst DISABLED_FIELD_CLASSNAME = \"sfv-disabled\";\nconst VALID_FIELD_CLASSNAME = \"sfv-ok\";\nconst INVALID_FIELD_CLASSNAME = \"sfv-error\";\n\nconst is = {\n  array: isArray,\n  function: isFunction,\n  number: isNumber,\n  object: isObject,\n  string: isString,\n};\n\nconst object = {\n  clone,\n  cloneAndExtend,\n  has: objectHas,\n};\n\n// eslint-disable-next-line\nmodule.exports = {\r\n  is,\n  object,\n  createListFromArray,\n  generateEffectName,\n  getEffectNames,\n  getValidatorNames,\n  isSubmitBtn,\n  normalizeId,\n  preEffectRegistrationCheck,\n  preValidatorRegistrationCheck,\n  validateId,\n  APP_CLASSNAME,\n  DISABLED_FIELD_CLASSNAME,\n  SMART_FIELD_CLASSNAME,\n  VALID_FIELD_CLASSNAME,\n  INVALID_FIELD_CLASSNAME,\n};\n\nfunction isArray(data) {\n  return Array.isArray(data);\n}\n\nfunction isFunction(data) {\n  return typeof data === \"function\";\n}\n\nfunction isNumber(num) {\n  num = Number(num);\n\n  return typeof num === \"number\" && !Number.isNaN(num);\n}\n\nfunction isObject(data) {\n  return (typeof data === \"object\" && data && !isArray(data));\n}\n\nfunction isString(data) {\n  return typeof data === \"string\";\n}\n\nfunction objectHas(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction clone(obj) {\n  return isObject(obj) ? Object.assign({}, obj) : obj;\n}\n\nfunction cloneAndExtend(obj, newProps) {\n  if(isObject(obj) && isObject(newProps)) {\n    return Object.assign(clone(obj), newProps);\n  } else {\n    return obj;\n  }\n}\n\nfunction createListFromArray(array, combinator) {\n  if(typeof combinator !== \"string\") {\n    combinator = \"\\t\\n* \";\n  }\n\n  return `${combinator}${array.join(combinator)}`;\n}\n\nfunction generateEffectName(name, namespace) {\n  name = is.string(name) ? name.trim() : \"\";\n  namespace = is.string(namespace) ? namespace.trim() : \"\";\n\n  if(name.length > 0 && namespace.length > 0) {\n    return `${namespace}.${name}`;\n  } else if(name.length > 0) {\n    return name;\n  } else {\n    return \"\";\n  }\n}\n\nfunction getEffectNames(effects) {\n  const effectObjects = Object.values(effects);\n  const effectNames = effectObjects.map(effect => effect.name);\n\n  return effectNames;\n}\n\nfunction getValidatorNames(validators) {\n  return Object.keys(validators);\n}\n\nfunction isSubmitBtn(element) {\n  return element.type === \"submit\" || element.role === \"submit-button\";\n}\n\nfunction normalizeId(id) {\n  return String(id).trim();\n}\n\nfunction preEffectRegistrationCheck(effect, defaultEffectNames) {\n  if(!(is.object(effect))) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"effect\")\n        .replace(\":type:\", \"an object\")\n    );\n  }\n\n  let { name, meta, valid, invalid } = effect;\n\n  if(!(is.string(name))) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"effect.name\")\n        .replace(\":type:\", \"a string\")\n    );\n  }\n\n  let namespace = \"\";\n  name = name.trim();\n\n  if(!(is.function(valid))) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"effect.valid\")\n        .replace(\":type:\", \"a function\")\n    );\n  }\n\n  if(!(is.function(invalid))) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"effect.invalid\")\n        .replace(\":type:\", \"a function\")\n    );\n  }\n\n  if(is.object(meta) && is.string(meta.namespace)) {\n    namespace = meta.namespace.trim();\n  }\n\n  const effectName = generateEffectName(name, namespace);\n\n  if(effectName.length === 0) {\n    throw new TypeError(\n      errorMessages.fieldCannotBeEmpty\n        .replace(\":field:\", \"effect.name\")\n        .replace(\":type:\", \"string\")\n    );\n  }\n\n  if(defaultEffectNames.includes(effectName)) {\n    throw new TypeError(\n      errorMessages.argNamesAreReserved\n        .replace(\":argNames:\", \"names\")\n        .replace(\":argTypes:\", \"effect names\")\n        .replace(\":argValues:\", createListFromArray(defaultEffectNames))\n    );\n  }\n\n  return { ...effect, name: effectName };\n}\n\nfunction preValidatorRegistrationCheck(validatorKey, validatorFn, validatorMeta, defaultValidatorKeys) {\n  if(!(is.string(validatorKey))) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"validatorKey\")\n        .replace(\":type:\", \"a string\")\n    );\n  }\n\n  let validatorNamespace = \"\";\n\n  validatorKey = validatorKey.trim();\n\n  if(!validatorKey) {\n    throw new TypeError(\n      errorMessages.fieldCannotBeEmpty\n        .replace(\":field:\", \"validatorKey\")\n        .replace(\":type:\", \"string\"));\n  }\n\n  if(is.object(validatorMeta) && is.string(validatorMeta.namespace)) {\n    validatorNamespace = validatorMeta.namespace.trim();\n  }\n\n  validatorKey = generateValidatorKey(validatorKey, validatorNamespace);  \n\n  if(defaultValidatorKeys.includes(validatorKey)) {\n    throw new TypeError(\n      errorMessages.argNamesAreReserved\n        .replace(\":argNames:\", \"keys\")\n        .replace(\":argTypes:\", \"validator keys\")\n        .replace(\":argValues:\", createListFromArray(defaultValidatorKeys))\n    );\n  }\n\n  if(!(is.function(validatorFn))) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"validatorFn\")\n        .replace(\":type:\", \"a function\")\n    );\n  }\n\n  return validatorKey;\n}\n\nfunction validateId(id) {\n  return [\"number\", \"string\"].includes(typeof id) && Boolean(id);\n}\n\n\n// Helpers \nfunction generateValidatorKey(key, namespace) {\n  if(key.length > 0 && namespace.length > 0) {\n    return `${namespace}.${key}`;\n  } else if(key.length > 0) {\n    return key;\n  } else {\n    return \"\";\n  }\n}","const { is } = require(\"../helpers\");\n\n\nmodule.exports = {\n  isSubmitButton,\n};\n\n\nfunction isSubmitButton(element) {\n  return (\n    is.object(element) && (element.type === \"submit\" || element.role === \"submit-button\")\n  );\n}","const { is, VALID_FIELD_CLASSNAME, INVALID_FIELD_CLASSNAME } = require(\"../../helpers\");\nconst { isSubmitButton } = require(\"../effects-helpers\");\n\nmodule.exports = {\n  name: \"addBottomBorder\",\n  meta: {},\n  valid: handleValid,\n  invalid: handleInvalid,\n};\n\nfunction handleValid(field) {\n  if(!(is.object(field)) || isSubmitButton(field)) {\n    return;\n  }\n\n  field.classList.remove(INVALID_FIELD_CLASSNAME);\n  field.classList.add(VALID_FIELD_CLASSNAME);\n}\n  \nfunction handleInvalid(field) {\n  if(!(is.object(field)) || isSubmitButton(field)) {\n    return;\n  }\n\n  field.classList.remove(VALID_FIELD_CLASSNAME);\n  field.classList.add(INVALID_FIELD_CLASSNAME);\n}","const { is, VALID_FIELD_CLASSNAME, INVALID_FIELD_CLASSNAME } = require(\"../../helpers\");\nconst { isSubmitButton } = require(\"../effects-helpers\");\n\n\nmodule.exports = {\n  name: \"addValidationStatusIcons\",\n  meta: {},\n  valid: handleValid,\n  invalid: handleInvalid,\n};\n\n\nfunction handleValid(field) {\n  if(!(is.object(field)) || isSubmitButton(field)) {\n    return;\n  }\n\n  field.classList.remove(INVALID_FIELD_CLASSNAME);\n  field.classList.add(VALID_FIELD_CLASSNAME);\n}\n  \nfunction handleInvalid(field) {\n  if(!(is.object(field)) || isSubmitButton(field)) {\n    return;\n  }\n\n  field.classList.remove(VALID_FIELD_CLASSNAME);\n  field.classList.add(INVALID_FIELD_CLASSNAME);\n}","const { APP_CLASSNAME, DISABLED_FIELD_CLASSNAME } = require(\"../../helpers\");\nconst { isSubmitButton } = require(\"../effects-helpers\");\n\n\nmodule.exports = {\n  name: \"toggleSubmitButton\",\n  meta: {},\n  init,\n  valid: handleValid,\n  invalid: handleInvalid,\n};\n\n\nfunction init(field) {\n  // Initially disable the submit button\n  canSubmitForm(false, field);\n}\n\nfunction handleValid(field) {\n  canSubmitForm(true, field);\n}\n  \nfunction handleInvalid(field) {\n  canSubmitForm(false, field);\n}\n\n\n// Helper methods\nfunction canSubmitForm(validationPassed, input) {\n  try {\n    if(!isSubmitButton(input)) {\n      return;\n    }\n\n    const submitBtn = input;\n\n    if(validationPassed) {\n      submitBtn.removeAttribute(\"disabled\");\n      submitBtn.classList.remove(APP_CLASSNAME);\n      submitBtn.classList.remove(DISABLED_FIELD_CLASSNAME);\n    } else {\n      submitBtn.setAttribute(\"disabled\", true);\n      submitBtn.classList.add(APP_CLASSNAME);\n      submitBtn.classList.add(DISABLED_FIELD_CLASSNAME);\n    }\n  } catch(e) {\n    console.log(\"Unable to modify the submit button state: \", e.message);\n  }\n}\n","module.exports = {\n  addBottomBorder: require(\"./add-bottom-border\"),\n  addValidationStatusIcons: require(\"./add-validation-status-icons\"),\n  toggleSubmitButton: require(\"./toggle-submit-button\"),\n};","const { is, object } = require(\"../helpers\");\n\nconst regexRules = [\"g\", \"m\"];\n\nmodule.exports = {\n  createAlphanumericRegexObject,\n  getLengthRegex,\n  getRegexRules,\n};\n\nfunction createAlphanumericRegexObject(regexStr, rule, emptyLengthCharacter) {\n  let lenRegex;\n  \n  if(rule.length) {\n    lenRegex = getLengthRegex(rule.length);\n  } else {\n    lenRegex = emptyLengthCharacter || \"+\";\n  }\n  \n  regexStr = `${regexStr}${lenRegex}`;\n  regexStr = `^${regexStr}$`;\n  \n  return new RegExp(regexStr, getRegexRules(rule.matchCase));\n}\n  \nfunction getLengthRegex(lengthRule) {\n  let regexStr;\n  const len = object.clone(lengthRule) || {};\n  \n  if(len.min && len.max) {\n    if(Number(len.min) > Number(len.max)) {\n      const tmp = len.min;\n  \n      len.min = len.max;\n      len.max = tmp;\n    }\n  \n    regexStr = `{${len.min},${len.max}}`;\n  } else if(len.min) {\n    regexStr = `{${len.min},}`;\n  } else if(len.max) {\n    regexStr = `{0,${len.max}}`;\n  } else if(is.number(len)) {\n    regexStr = `{0,${len}}`;\n  }\n  \n  return regexStr;\n}\n  \nfunction getRegexRules(matchCase) {\n  if(matchCase) {\n    return regexRules.join(\"\");\n  } else {\n    return [...regexRules, \"i\"].join(\"\");\n  }\n}","const { createAlphanumericRegexObject } = require(\"./validator-helpers\");\n\n/**\n* Validate that a string contains only alphanumeric characters, _ (underscore), or - (hyphen). \n* @param {String} value (required): The string to validate\n* @param {Object} rule (required): Object containing the requirements for the value to be valid.\n* @param {String} [rule.type]: the expected type of the value.\n* @param {Boolean} [rule.allowWhitespace] (optional): specifies whether to allow whitespace or not.\n* @param {Boolean} [rule.matchCase]: true for case-sensitive validation, false for case-insensitive validation.\n* @returns {Boolean}\n*/\nmodule.exports = function alphanumericValidator(value, rule) {\n  if(!rule.type || rule.type !== \"alnum\") {\n    return true; // if the \"alnum\" rule has not been defined for this value, bypass this validator\n  }\n\n  if(!value) {\n    return false;\n  }\n\n  const regexStr = rule.allowWhitespace ? \"[A-Z0-9\\\\s_-]\" : \"[A-Z0-9_-]\";\n  const regex = createAlphanumericRegexObject(regexStr, rule);\n\n  return regex.test(value);\n};","const { createAlphanumericRegexObject } = require(\"./validator-helpers\");\n\n/**\n * Validate that a string contains only the characters A - Z, _ (underscore), or - (hyphen). \n * @param {String} value (required): The string to validate\n * @param {Object} rule (required): Object containing the requirements for the value to be valid.\n * @param {String} [rule.type]: the expected type of the value.\n * @param {Boolean} [rule.allowWhitespace] (optional): specifies whether to allow whitespace or not.\n * @param {Boolean} [rule.matchCase]: true for case-sensitive validation, false for case-insensitive validation.\n * @returns {Boolean}\n */\nmodule.exports = function alphaValidator(value, rule) {\n  if(!rule.type || rule.type !== \"alpha\") {\n    return true; // if the \"alpha\" rule has not been defined for this value, bypass this validator\n  }\n\n  if(!value || typeof value !== \"string\") {\n    return false;\n  }\n  \n  const regexStr = rule.allowWhitespace ? \"[A-Z\\\\s_-]\" : \"[A-Z_-]\";\n  const regex = createAlphanumericRegexObject(regexStr, rule);\n  \n  return regex.test(value);\n};","const { createAlphanumericRegexObject } = require(\"./validator-helpers\");\n\n/**\n * Validate that a string contains only ascii text characters. \n * @param {String} value (required): The string to validate\n * @param {Object} rule (required): Object containing the requirements for the value to be valid.\n * @param {String} [rule.type]: the expected type of the value.\n * @param {Boolean} [rule.matchCase]: true for case-sensitive validation, false for case-insensitive validation.\n * @returns {Boolean}\n */\nmodule.exports = function asciiTextValidator(value, rule) {\n  if(!rule.type || rule.type !== \"ascii\") {\n    return true; // if the \"ascii\" rule has not been defined for this value, bypass this validator\n  }\n\n  if(!value) {\n    return false;\n  }\n  \n  const regexStr = \"[A-Z0-9`~!@#$%^&*()-+=\\\\[\\\\]{}\\\\\\\\;:'\\\"|<>?\\\\,\\\\.?\\\\/\\\\s_-]\"; // \\\\\\\\ = support for backward slash\n  const regex = createAlphanumericRegexObject(regexStr, rule);\n  \n  return regex.test(value);\n};","// Credits: https://github.com/manishsaraan/email-validator/blob/master/index.js\n//\n// Thanks to:\n// http://fightingforalostcause.net/misc/2006/compare-email-regex.php\n// http://thedailywtf.com/Articles/Validating_Email_Addresses.aspx\n// http://stackoverflow.com/questions/201323/what-is-the-best-regular-expression-for-validating-email-addresses/201378#201378\n// https://en.wikipedia.org/wiki/Email_address  The format of an email address is local-part@domain, where the \n// local part may be up to 64 octets long and the domain may have a maximum of 255 octets.[4]\n//\n\nconst regex = /^[-!#$%&'*+/0-9=?A-Z^_a-z`{|}~](\\.?[-!#$%&'*+/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\\.?[a-zA-Z0-9])*\\.[a-zA-Z](-?[a-zA-Z0-9])+$/;\n\n/**\n * Validate that a string is an email.\n * @param {String} value (required): The value to validate\n * @param {Object} rule (required): Object containing the requirements for the value to be valid.\n * @param {String} [rule.type]: the expected type of the value.\n * @returns {Boolean}\n */\nmodule.exports = function emailValidator(value, rule) {\n  if(!rule.type || rule.type !== \"email\") {\n    return true; // if the \"email\" rule has not been defined for this value, bypass this validator\n  }\n\n  if(!value || typeof value !== \"string\") {\n    return false;\n  }\n  \n  const emailParts = value.split(\"@\");\n  \n  if(emailParts.length !== 2) {\n    return false;\n  }\n  \n  const [account, address] = emailParts;\n  \n  if(account.length > 64 || address.length > 255) {\n    return false;\n  }\n  \n  const domainParts = address.split(\".\");\n    \n  if(domainParts.some(part => part.length > 63)) {\n    return false;\n  }\n  \n  return regex.test(value);\n};","const { is } = require(\"../helpers\");\nconst { createAlphanumericRegexObject } = require(\"./validator-helpers\");\n\n/**\n * Validate that a string conforms to the passed length requirements.\n * @param {String} value (required): The value to validate\n * @param {Object} rule (required): Object containing the requirements for the value to be valid.\n * @param {Number|Object} [rule.length] (required): The length requirements.\n * @param {Number} [rule.length.min] (optional): minimum length requirement.\n * @param {Number} [rule.length.max] (optional): maximum length requirement.\n * @returns {Boolean}\n */\nmodule.exports = function lengthValidator(value, rule) {\n  if(!(is.number(rule.length)) && !(is.object(rule.length))) {\n    return true; // If the length rule has not been defined for the value, bypass this validator\n  }\n\n  if(typeof value === \"undefined\" || value === null || value === false) {\n    return false;\n  }\n  \n  const regexStr = \"[A-Z0-9.\\\\s_-]\";\n  const regex = createAlphanumericRegexObject(regexStr, rule, \"*\");\n  \n  return regex.test(value);\n};","const { createAlphanumericRegexObject } = require(\"./validator-helpers\");\n\n/**\n * Validate that a value contains only numbers. \n * @param {Number|String} value (required): The string to validate\n * @param {Object} rule (required): Object containing the requirements for the value to be valid.\n * @param {String} [rule.type]: The expected type of the value.\n * @param {Boolean} [rule.allowWhitespace] (optional): specifies whether to allow whitespace or not.\n * @returns {Boolean}\n */\nmodule.exports = function numberValidator(value, rule) {\n  if(!rule.type || rule.type !== \"number\") {\n    return true; // If the \"number\" rule has not been specified for this value, bypass this validator.\n  }\n\n  if(value === \"\" || value === null || typeof value === \"undefined\") {\n    return false;\n  }\n  \n  const regexStr = rule.allowWhitespace ? \"[0-9\\\\s]\" : \"[0-9]\";\n  const regex = createAlphanumericRegexObject(regexStr, rule);\n  \n  return regex.test(value);\n};","const { is } = require(\"../helpers\");\n\n\n/**\n * Validate a value according to provided custom regular expression.\n * @param {Mixed} value (required): The value to validate\n * @param {Object} rule (required): Object containing the requirements for the value to be valid.\n * @param {Object|String} [rule.regex]: A regex string or a regex object.\n * @returns {Boolean}\n */\nmodule.exports = function regexValidator(value, rule) {\n  if(!rule.regex) {\n    return true; // if the regex rule has not been defined for this value, bypass this validator\n  }\n\n  const { regex: regexStr } = rule;\n  const regex = is.object(regexStr) ? regexStr : new RegExp(regexStr);\n  \n  return regex.test(value);\n};","module.exports = {\n  alphanumericValidator: require(\"./alphanumeric-validator\"),\n  alphaValidator: require(\"./alpha-validator\"),\n  asciiTextValidator: require(\"./ascii-text-validator\"),\n  emailValidator: require(\"./email-validator\"),\n  lengthValidator: require(\"./length-validator\"),\n  numberValidator: require(\"./number-validator\"),\n  regexValidator: require(\"./regex-validator\"),\n  requiredFieldValidator: require(\"./required-field-validator\"),\n};\n","/**\n * Validate that a value is not empty, that is, not undefined. \n * @param {String} value (required): The value to validate\n * @param {Object} rule (required): Object containing the requirements for the value to be valid.\n * @param {Boolean} [rule.required]: Dictates whether or not the value is required.\n * @param {Boolean} prevResult (optional);\n * @param {Object} extras\n * @param {Boolean} [extras.checked] (optional): if the value is of a checkbox, .\n * @returns {Boolean}\n */\nmodule.exports = function requiredFieldValidator(value, rule, _, extras) {\n  if(!rule.required) {\n    return true; // bypass this validation if no rule has been specified for it.\n  }\n\n  if(value === \"\" || typeof value === \"undefined\") {\n    return false;\n  }\n  \n  let passed;\n  \n  switch(rule.type) {\n  case \"checkbox\" : passed = extras.checked && value === \"on\"; break;\n  default         : passed = value.length > 0; break;\n  }\n  \n  return passed;\n};","\"use strict\";\n\nconst effects = require(\"./effects\");\nconst errorMessages = require(\"./error-messages\");\nconst { \n  APP_CLASSNAME,  \n  SMART_FIELD_CLASSNAME,\n  is,\n  object,\n  generateEffectName,\n  getEffectNames,\n  getValidatorNames,\n  preEffectRegistrationCheck,\n  preValidatorRegistrationCheck,\n  isSubmitBtn,\n  normalizeId,\n  validateId,\n} = require(\"./helpers\");\nconst defaultValidators = require(\"./validators\");\n\nconst defaultEffects = Object.values(effects);\nconst defaultEffectNames = getEffectNames(effects);\nconst defaultValidatorFunctions = Object.entries(defaultValidators);\nconst defaultValidatorKeys = getValidatorNames(defaultValidators); //Object.keys(defaultValidators);\n\n\nmodule.exports = SmartField;\n\n\n/**\n * Create a new SmartField object.\n * @param {Object} element: the element to create a SmartField instance from;\n * @param {String} [element.id] (required): the id of the element \n * @param {String} [element.role] (optional): the role of the element. \n *    This can be particularly usefule for identifying submit buttons that are not defined \n *    as `<input type=\"submit\" />`. In such cases, if we want effects that work with submit buttons \n *    to have access to the button, we have to give the element a role of \"submit-button\", e.g. \n *    `<button role=\"submit-button\">Submit</button>`.\n * @param {Function} [element.getValue] (optional): A function to get the element's value.\n *    The function should return the element's value when called.\n *    If the element is an HTML element such as `input`, `select`, `checkbox`, or a contenteditable field, \n *    this property is optional, and the element's value can be retrieved automatically. \n *    For other types of elements, this value is required for getting the element's value during validation.\n * @param {Object} rule (optional): object specifying the validation rules to apply to this instance.\n * @param {Boolean} [rule.required]: specifies whether the field is required (true) or not (false)\n * @param {Number|Object} [rule.length]: specifies the accepted input length. \n *    If the value is a number, it specifies the maximum length.\n *    If the value is an object, it specifies. the minimum and/or maximum length.\n * @param {Number} [rule.length.min]: specifies the mininum accepted input length\n * @param {Number} [rule.length.max]: specifies the maximum accepted input length\n * @param {Boolean} [rule.matchCase]: performs a case-sensitive (true) or case-insensitive (false) validation.\n * @param {String} [rule.type]: the acceptable data type of the value  for this field (alnum|alpha|ascii|email|number).\n *    Default is alnum.\n * @param {String} [rule.regex]: specifies a custom validation regex.\n * \n * @returns this\n * \n * Before the field can have any validation performed on it, a rule must be added to it\n * either durinc initialization or by calling the addRule(rule) method on the instance.\n */\nfunction SmartField(element, rule) {\n  if(!is.object(element)) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"element\")\n        .replace(\":type:\", \"object\")\n    );\n  }\n\n  if(!validateId(element.id) && !isSubmitBtn(element)) {\n    throw new TypeError(\n      errorMessages\n        .objectPropertyShouldHaveType\n        .replace(\":prop:\", \"id\")\n        .replace(\":object:\", \"element\")\n        .replace(\":type:\", \"a string or a number\")\n    );\n  }\n\n  if(normalizeId(element.id).length === 0 && !isSubmitBtn(element)) {\n    throw new TypeError(\n      errorMessages\n        .objectPropertyCannotBeEmpty\n        .replace(\":prop:\", \"id\")\n        .replace(\":object:\", \"element\")\n    );\n  }\n\n  if(typeof element.getValue !== \"undefined\" && typeof element.getValue !== \"function\") {\n    throw new TypeError(\n      errorMessages\n        .objectPropertyShouldHaveType\n        .replace(\":prop:\", \"getValue\")\n        .replace(\":object:\", \"element\")\n        .replace(\":type:\", \"a function\")\n    );\n  }\n\n  if(isSubmitBtn(element)) {\n    this.role = \"submit-button\";\n  }\n\n  this.id = element.id;\n  this.element = element;\n  this.defaultEffects = new Map();\n  this.defaultValidators = new Map(defaultValidatorFunctions);\n  this.effects = new Map();\n  this.validators = new Map();\n\n  for(const effect of defaultEffects) {\n    const { name, meta, init, valid, invalid } = effect;\n\n    this.defaultEffects.set(name, { meta, init, valid, invalid });\n\n    if(is.function(init)) {\n      init(this.element);\n    }\n  }\n\n  if(is.object(rule)) {\n    this.addRule({ ...rule, fieldId: element.id });\n  }\n\n  claimField(element);\n}\n\n/**\n * Add a new rule to a SmartField instance or update the existing rule for the instance.\n * @param {Object} rule: Object containing the requirements for the field's value to be valid.\n * @param {Boolean} [rule.required]: (for checkbox, dropdown, and text fields): determines if the field is required.\n * @param {Number|Object} [rule.length]: specify the accepted input length. \n *    If the value is a number, it specifies the maximum length.\n *    If the value is an object, it specifies the minimum and/or maximum length.\n * @param {Number} [rule.length.min]: specifies the mininum accepted input length\n * @param {Number} [rule.length.max]: specifies the maximum accepted input length\n * @param {Boolean} [rule.allowWhitespace]: specifies if white-space characters are allowed.\n * @param {Boolean} [rule.matchCase]: performs a case-sensitive (true) or case-insensitive(false) validation.\n * @param {String} [rule.type]: the input field's expected data type (alnum|alpha|ascii|email|number|text).\n *    Default is alnum.\n * @param {String} [rule.regex]: specifies a custom validation regex\n * @param {Boolean} replace (optional): replace the existing rule completely with the new rule.\n *    This will not only overwrite a specific key, but replace the entire previous `rule` object.\n * \n * @returns this\n * \n */\nSmartField.prototype.addRule = function addRule(rule) {\n  const existingRule = this.rule;\n  \n  if(is.object(existingRule) && is.object(rule)) {\n    this.rule = object.cloneAndExtend(existingRule, rule);\n  } else {\n    this.rule = rule;\n  }\n  \n  return this;\n};\n\n/**\n * Delete the rule for this instance.\n * @param {String} key (optional): If specified, delete only the specified rule.\n * Otherwise, delete the entire rule object for this instance.\n * \n * @returns this\n */\nSmartField.prototype.removeRule = function removeRule(key) {\n  const existingRule = this.rule;\n\n  if(!is.object(existingRule)) {\n    return this;\n  }\n  \n  if(key) {\n    delete this.rule[key];\n  } else {\n    delete this.rule;\n  }\n\n  return this;\n};\n\n/**\n * Get the rule object associated with this field\n * @param {String} key (optional): get specific rule by key.\n * @return {Boolean|Object|String|Undefined}\n */\nSmartField.prototype.getRule = function getRule(key) {\n  if(key && this.rule) {\n    return typeof this.rule[key] !== \"undefined\" ? this.rule[key] : null;\n  } else {\n    return this.rule || null;\n  }\n};\n\n/**\n * getEffect:  retrieves an effect attached to this field by name.\n * \n * @param {String} name (required)\n * @param {String} namespace (optional)\n * @returns {Boolean}\n */\nSmartField.prototype.getEffect = function getEffect(name, namespace) {\n  name = is.string(name) ? name.trim().toLowerCase() : \"\";\n  namespace = is.string(namespace) ? namespace.trim().toLowerCase() : \"\";\n\n  const effectName = generateEffectName(name, namespace);\n\n  if(this.effects.has(effectName)) {\n    return this.effects.get(effectName);\n  } else {\n    return null;\n  }\n};\n\n/**\n * @param {String} type (optional): \"addon\"|\"default\".\n * @returns {Object} with members: `default` and/or `addon`.\n */\nSmartField.prototype.getEffects = function getActiveEffects(type) {\n  type = is.string(type) ? type.toLowerCase().trim() : \"\";\n\n  const effects = {\n    default: this.defaultEffects,\n    addon: this.effects,\n  };\n\n  if([\"addon\", \"default\"].includes(type)) {\n    return effects[type];\n  } else {\n    return effects;\n  }\n};\n\n/**\n * \n * @param {Object} effect: \n * @param {String} [effect.name] (required): The name of this effect, used when registering the effect.\n * @param {Function} [effects.init] (optional): Function that performs any initialization function.\n *    The function is invoked right after the effect is registered.\n *    It receives the current input field as its first argument.\n * @param {Function} [effect.valid] (required): Function to invoke post-validation if the field is valid.\n *    The function receives the validated input field as its first argument.\n * @param {Function} [effect.invalid] (required): Function to invoke post-validation if the field is invalid.\n *    The function is passed the validated input field as its first argument\n * @param {Object} [effect.meta] (optional): Effect meta data, e.g., namespace, author, version, etc.\n * @param {String} [effect.meta.namespace]: used in conjunction with the effect `name` \n *    to create a unique name for the effect.\n * @returns this.\n */\nSmartField.prototype.useEffect = function useEffect(effect) {\n  const parsedEffect = preEffectRegistrationCheck(effect, defaultEffectNames);\n\n  let { name: effectName, meta, init, valid, invalid } = parsedEffect;\n\n  if(this.usesEffect(effectName)) {\n    throw new TypeError(\n      errorMessages.objectWithKeyExists\n        .replace(\":object:\", \"An effect\")\n        .replace(\":key:\", effectName)\n    );\n  }\n\n  this.effects.set(effectName, { meta, init, valid, invalid });\n\n  if(is.function(init)) {\n    init(this.getElement());\n  }\n\n  return this;\n};\n\n/**\n * usesEffect: checks whether the field has any effects attached to.\n * If the `name` (and/or `namespace`) parameter is supplied, \n * checks if the field has the named effect attached.\n * \n * @param {String} name (optional)\n * @param {String} namespace (optional)\n * @returns {Boolean}\n */\nSmartField.prototype.usesEffect = function usesEffect(name, namespace) {\n  if(is.string(name)) {\n    name = name.trim().toLowerCase();\n    namespace = is.string(namespace) ? namespace.trim().toLowerCase() : \"\";\n\n    const effectName = generateEffectName(name, namespace);\n\n    return this.effects.has(effectName);\n  } else {\n    return this.effects.size > 0;\n  }\n};\n\n/**\n * Add a validator to the list of validators for this field.\n * \n * @param {String} validatorKey (required): The identifier for the validator.\n * @param {Function} validatorFn (required): A function that validates the field.\n *    The function is passed the following arguments in order: \n *       - `value`: the value entered by the user for this field\n *       - `rule`: the rule defined for this field instance\n *       - `prevResult`: a Boolean value indicating the result of previous validators.\n *       - `extras`: object containing any other field-specific information, \n *             like the \"checked\" state for checkboxes, etc.\n *    The function should return Boolean true or false to indicate if the validation passed.\n * @param {Object} validatorMeta (optional): Object containing validator metadata (namespace, author, etc.)\n * @param {String} [validatorMeta.namespace]: namespace of the validator. \n *    This is appended to the key to prevent naming conflicts.\n * @returns this.\n */\nSmartField.prototype.addValidator = function addValidator(validatorKey, validatorFn, validatorMeta) {\n  validatorKey = preValidatorRegistrationCheck(validatorKey, validatorFn, validatorMeta, defaultValidatorKeys);\n\n  if(this.hasValidator(validatorKey)) {\n    throw new TypeError(\n      errorMessages.objectWithKeyExists\n        .replace(\":object:\", \"A validator\")\n        .replace(\":key:\", validatorKey)\n    );\n  }\n\n  this.validators.set(validatorKey, validatorFn);\n\n  return this;\n};\n\n/**\n * @param {String} type (optional): \"addon\"|\"default\".\n * @returns {Object} with members: `default` and/or `addon`.\n */\nSmartField.prototype.getValidators = function getValidators(type) {\n  type = is.string(type) ? type.toLowerCase().trim() : \"\";\n\n  const validators = {\n    default: this.defaultValidators,\n    addon: this.validators,\n  };\n\n  if([\"addon\", \"default\"].includes(type)) {\n    return validators[type];\n  } else {\n    return validators;\n  }\n};\n\nSmartField.prototype.hasValidator = function hasValidator(validatorKey) {\n  if(is.string(validatorKey)) {\n    validatorKey = validatorKey.trim().toLowerCase();\n  }\n\n  return (\n    is.string(validatorKey)\n      ? this.validators.has(validatorKey) \n      : this.validators.size > 0\n  );\n};\n\n/**\n * Get the original input field passed to the constructor\n * @returns \n */\nSmartField.prototype.getElement = function getElement() { \n  return this.element;\n};\n\n/**\n * Get the value entered by the user for this field\n * @returns {String|Mixed}\n */\nSmartField.prototype.getValue = function getValue() {\n  let value;\n  let input = this.getElement();\n\n  if(typeof input.getValue === \"function\") {\n    value = input.getValue();\n  } else if(input.type?.toLowerCase() === \"checkbox\") {\n    value = input.value;\n  } else if(input.tagName?.toLowerCase() === \"select\") {\n    value = getHtmlSelectElementSelectedOption(input)?.value?.trim();\n  } else if(typeof input.value !== \"undefined\") {\n    value = input.value;\n  } else if(input.isContentEditable && typeof input.textContent !== \"undefined\") {\n    value = input.textContent;\n  }\n\n  return ( is.string(value) ? value.trim() : value );\n};\n\n/**\n * @returns {Boolean}\n */\nSmartField.prototype.validate = function validate() {\n  const { default: defaultValidators, addon: addonValidators } = this.getValidators();\n  const validators = Array.from(defaultValidators.values()).concat(Array.from(addonValidators.values()));\n\n  if(validators.length === 0) {\n    throw new TypeError(errorMessages.noValidatorsActive);\n  }\n\n  const { default: defaultEffects, addon: addonEffects } = this.getEffects();\n  const effects = Array.from(defaultEffects.values()).concat(Array.from(addonEffects.values()));\n\n  if(effects.length === 0) {\n    throw new TypeError(errorMessages.noEffectsActive);\n  }\n\n  let rule = this.getRule();\n  const input = this.getElement();\n  const value = this.getValue();\n  const extras = {};\n\n  if(rule.required && input.type === \"checkbox\") {\n    extras.checked = input.checked;\n  }\n\n  const validationPassed = validators.reduce((passed, fn) => passed && fn(value, rule, passed, extras), true);\n\n  effects.forEach(({ valid, invalid }) => {\n    if(validationPassed) {\n      valid(input);\n    } else {\n      invalid(input);\n    }\n  });\n\n  return validationPassed;\n};\n\n/**\n * Start Listening for \"input\" events and perform validation\n * @param {Function} callback: A function to invoke on validation complete.\n *   The function will be passed the input field and the result (Boolean) of the validation.\n */\nSmartField.prototype.watch = function watch(callback) {\n  const input = this.getElement();\n  let targetEvent;\n  \n  switch(input.type) {\n  case \"checkbox\" : targetEvent = \"click\"; break;\n  case \"email\"    :\n  case \"password\" : \n  case \"text\"     : \n  default         : targetEvent = \"input\"; break;\n  }\n  \n  input.addEventListener(targetEvent, () => this.validate(_, callback)); // eslint-disable-line\r\n};\n\n\n// Helpers\n\nfunction getHtmlSelectElementSelectedOption(selectElement) {\n  return {\n    value : selectElement.value,\n    text  : selectElement.options[selectElement.selectedIndex].text,\n  };\n}\n\nfunction claimField(input) {\n  input.classList?.add(APP_CLASSNAME);\n  input.classList?.add(SMART_FIELD_CLASSNAME);\n}","const errorMessages = require(\"../error-messages\");\nconst { is, isSubmitBtn, normalizeId, validateId } = require(\"../helpers\");\nconst SmartField = require(\"../smart-field\");\n\n/**\n * Add a new field for validation\n * @param {Object|String} input: the field to validate. The field must have an `id` property.\n *    This can be the HTML element itself if we already have it, or its ID.\n * @param {String} [input.id] (required): the id of the element \n * @param {String} [input.role] (optional): the role of the element. \n *    This can be particularly useful for identifying submit buttons that are not defined \n *    as `<input type=\"submit\" />`. In such cases, if we want effects that work with submit buttons \n *    to have access to the button, we have to give the element a role of \"submit-button\", e.g. \n *    `<button role=\"submit-button\">Submit</button>`.\n * @param {Object} rule (optional): object containing validation rules for this field.\n * @param {Boolean} [rule.required]: specifies whether the field is required (true) or not (false)\n * @param {Number|Object} [rule.length]: specifies the accepted input length. \n *   If the value is a number, it specifies the maximum length. \n *   If the value is an object, it specifies the minimum and/or maximum length.\n * @param {Number} [rule.length.min]: specifies the mininum accepted input length\n * @param {Number} [rule.length.max]: specifies the maximum accepted input length\n * @param {Boolean} [rule.matchCase]: performs case-sensitive (true) or case-insensitive (false) validation.\n * @param {String} [rule.type]: the field's expected data type (alnum|alpha|email|number|text).\n *    Default is alnum.\n * @param {String} [rule.regex]: specifies a custom validation regex\n * @returns this\n */\nmodule.exports = function addField(input, rule) {\n  if(typeof input === \"string\") {\n    input = document.getElementById(input);\n  }\n\n  if(!is.object(input)) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"input\")\n        .replace(\":type:\", \"object\")\n    );\n  }\n  \n  if(!validateId(input.id) && !isSubmitBtn(input)) {\n    throw new TypeError(\n      errorMessages.objectPropertyShouldHaveType\n        .replace(\":prop:\", \"id\")\n        .replace(\":object:\", \"input\")\n        .replace(\":type:\", \"a string or a number\")\n    );\n  }\n  \n  const field = this.getField(normalizeId(input.id));\n  \n  if(field) {\n    if(is.object(rule)) {\n      rule.field = input.id;\n  \n      this.addRule(rule);\n    }\n  } else {\n    this.fields.push(new SmartField(input, rule));\n  }\n    \n  return this;\n};","const { is } = require(\"../helpers\");\n\n/**\n * Add an array of new fields for validation.\n * @param {Array} fields: the fields to validate. \n * @param {Object} [fields[i].field]: An object holding the input field to validate, must have an `id` property.\n * @param {String} [fields[i].field.id]: The id of the input field\n * @param {Object} [fields[i].rule]: (optional): object containing validation rules for this field.\n * @param {Boolean} [fields[i].rule.required]: specifies whether the field is required (true) or not (false)\n * @param {Number|Object} [fields[i].rule.length]: specifies the accepted input length. \n *   If the value is a number, it specifies the maximum length. \n *   If the value is an object, it specifies the minimum and/or maximum length.\n * @param {Number} [fields[i].rule.length.min]: specifies the mininum accepted input length\n * @param {Number} [fields[i].rule.length.max]: specifies the maximum accepted input length\n * @param {Booleean} [fields[i].rule.allowWhitespace]\n * @param {Boolean} [fields[i].rule.matchCase]: performs case-sensitive (true) or case-insensitive (false) validation.\n * @param {String} [fields[i].rule.type]: the field's expected data type (alnum|alpha|email|number|text).\n *    Default is alnum.\n * @param {String} [fields[i].rule.regex]: specifies a custom validation regex\n * @returns this\n * \n * Only fields that have rules added to them will be considered for validation.\n */\nmodule.exports = function addFields(fields) {\n  if(is.array(fields) && fields.length > 0) {\n    fields.forEach(field => this.addField(field.field, field.rule));\n  }\n\n  return this;\n};","const errorMessages = require(\"../error-messages\");\nconst { is, object } = require(\"../helpers\");\n\n\n/**\n * Add a validation rule to a previuosly created field.\n * @param {Object} rule: object\n * @param {Object|String} [rule.field]: the field to apply the rule to. This can be the element itself or its id.\n * @param {Boolean} [rule.required]: specifies whether the field is required (true) or not (false)\n * @param {Number|Object} [rule.length]: specifies the accepted input length. \n *    If the value is a number, it specifies the maximum length.\n *    If the value is an object, it specifies the minimum and/or maximum accepted length.\n * @param {Number} [rule.length.min]: specify the mininum accepted input length\n * @param {Number} [rule.length.max]: specify the maximum accepted input length\n * @param {Boolean} [rule.allowWhitespace]: specifies if white-space characters are allowed.\n * @param {Boolean} [rule.matchCase]: performs a case-sensitive (true) or case-insensitive (false) validation\n * @param {String} [rule.type]: the input field's expected data type (alnum|alpha|email|number|text).\n *    Default is alnum.\n * @param {String} [rule.regex]: specifies a custom validation regex\n * @returns this\n */\nmodule.exports = function addRule(rule) {\n  if(!is.object(rule)) {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"rule\")\n        .replace(\":type:\", \"object\")\n    );\n  }\n  \n  if(!object.has(rule, \"field\")) {\n    throw new TypeError(\n      errorMessages.objectMustHaveProperty\n        .replace(\":param:\", \"rule\")\n        .replace(\":prop:\", \"field\")\n    );\n  }\n  \n  const fieldId = is.object(rule.field) ? rule.field.id : rule.field;\n  const field = this.getField(fieldId);\n  \n  if(!field) {\n    throw new TypeError(\n      errorMessages.fieldNotRegistered\n        .replace(\":element:\", \"validator\")\n        .replace(\":id:\", fieldId)\n    );\n  }\n  \n  field.addRule(rule);\n  \n  return this;\n};\n  ","const errorMessages = require(\"../error-messages\");\nconst { getValidatorNames, preValidatorRegistrationCheck } = require(\"../helpers\");\nconst defaultValidators = require(\"../validators\");\n\nconst defaultValidatorKeys = getValidatorNames(defaultValidators); //Object.keys(defaultValidators);\n\n\nmodule.exports = function addValidator(validatorKey, validatorFn, validatorMeta) {\n  this.validators = this.validators || {};\n  \n  validatorKey = preValidatorRegistrationCheck(validatorKey, validatorFn, validatorMeta, defaultValidatorKeys);\n  \n  if(this.validators[validatorKey]) {\n    throw new TypeError(\n      errorMessages.objectWithKeyExists\n        .replace(\":object:\", \"A validator\")\n        .replace(\":key:\", validatorKey)\n    );\n  }\n  \n  this.validators[validatorKey] = validatorFn;\n  \n  // Add the effect to the elements attached to the instance.\n  if(typeof this.getFields === \"function\") {\n    this.getFields().forEach(field => {\n      if(!(field.hasValidator(validatorKey))) {\n        field.addValidator(validatorKey, validatorFn, validatorMeta);\n      }\n    });\n  }\n};\n","const effects = require(\"../effects\");\nconst { is } = require(\"../helpers\");\n\nconst defaultEffects = {};\n\nfor(const effect of Object.values(effects)) {\n  const { name, meta, init, valid, invalid } = effect;\n\n  defaultEffects[name] = { meta, init, valid, invalid };\n}\n\n/**\n * @param {String} type (optional): \"addon\"|\"default\".\n * @returns {Object} with members: `default` and/or `addon`.\n */\nmodule.exports = function getEffects(type) {\n  type = is.string(type) ? type.trim().toLowerCase() : \"\";\n\n  const addonEffects = this.effects || null;\n\n  if([\"addon\", \"default\"].includes(type)) {\n    switch(type) {\n    case \"default\": return defaultEffects;\n    case \"addon\"  : return addonEffects;\n    }\n  } else {\n    return {\n      default: defaultEffects,\n      addon: addonEffects,\n    };\n  }\n};\n","const { normalizeId } = require(\"../helpers\");\n\n\nmodule.exports = function getField(fieldId) {\n  return this.getFields().find(field => normalizeId(field.id) === normalizeId(fieldId)) || null;\n};","/**\n * Get all fields\n * @returns {Array}\n */\nmodule.exports = function getFields() {\n  return this.fields;\n};","const validators = require(\"../validators\");\nconst { is } = require(\"../helpers\");\n\nconst defaultValidators = {};\n\nfor(const [key, validator] of Object.entries(validators)) {\n  defaultValidators[key] = validator;\n}\n\n/**\n * @param {String} type (optional): \"addon\"|\"default\".\n * @returns {Object} with members: `default` and/or `addon`.\n */\nmodule.exports = function getValidator(type) {\n  type = is.string(type) ? type.trim().toLowerCase() : \"\";\n\n  const addonValidators = this.validators || null;\n\n  if([\"addon\", \"default\"].includes(type)) {\n    switch(type) {\n    case \"default\": return defaultValidators;\n    case \"addon\"  : return addonValidators;\n    }\n  } else {\n    return {\n      default: defaultValidators,\n      addon: addonValidators,\n    };\n  }\n};\n","const { is } = require(\"../helpers\");\n\n\n/**\n * \n * @param {Number|String} element: the field whose rule we want to delete. This can be the underlying element or its id.\n * @param {String} key (optional): the key of the rule we want to delete. \n *    If not specified, the entire rule for the field is deleted.\n *    This means no more validation will take place for that field.\n * @returns this\n */\nmodule.exports = function removeRule(element, key) {\n  const fieldId = is.object(element) ? element.id : element;\n  const field = this.getField(fieldId);\n  \n  if(field) {\n    field.removeRule(key);\n  }\n  \n  return this;\n};","/**\n * Support JSON.stringify\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\n */\nmodule.exports = function toJSON() {\n  return this.getFields();\n};","const effects = require(\"../effects\");\nconst errorMessages = require(\"../error-messages\");\nconst { getEffectNames, preEffectRegistrationCheck } = require(\"../helpers\");\n\nconst defaultEffectNames = getEffectNames(effects);\n\n/**\n * @param {Object} effect: \n * @param {String} [effect.name] (required): The name of this effect, used when registering the effect.\n * @param {Function} [effects.init] (optional): Function that performs any initialization function.\n *    The function is invoked right after the effect is registered.\n *    It receives the current input field as its first argument.\n * @param {Function} [effect.valid] (required): Function to invoke post-validation if the field is valid.\n *    The function receives the validated input field as its first argument.\n * @param {Function} [effect.invalid] (required): Function to invoke post-validation if the field is invalid.\n *    The function is passed the validated input field as its first argument\n * @param {Object} [effect.meta] (optional): Effect meta data, e.g., namespace, author, version, etc.\n * @param {String} [effect.meta.namespace]: used in conjunction with the effect `name` \n *    to create a unique name for the effect.\n * @returns this.\n */\nmodule.exports = function useEffect(effect) {\n  this.effects = this.effects || {};\n\n  const parsedEffect = preEffectRegistrationCheck(effect, defaultEffectNames);\n\n  let { name: effectName, meta, init, valid, invalid } = parsedEffect;\n\n  if(this.effects[effectName]) {\n    throw new TypeError(\n      errorMessages.objectWithKeyExists\n        .replace(\":object:\", \"An effect\")\n        .replace(\":key:\", effectName)\n    );\n  }\n\n  this.effects[effectName] = { meta, init, valid, invalid };\n\n  // Add the effect to the elements attached to the instance.\n  if(typeof this.getFields === \"function\") {\n    this.getFields().forEach(field => {\n      if(!(field.usesEffect(effect.name, effect.meta?.namespace))) {\n        field.useEffect(effect);\n      }\n    });\n  }\n};","/**\n * @returns {Boolean}: the overall result of the entire validation\n */\nmodule.exports = function validate() {\n  const validated = this.getFields().map(field => field.validate());\n  \n  return validated.every(passed => Boolean(passed));\n};","const errorMessages = require(\"../error-messages\");\n\n\n/**\n * Listen for input changes on a form's input members\n * and invoke the handleInputChange for each input element in the form\n * @param {Function} callback: A validation callback, \n *   the function will be invoked for each input field validated and \n *   will receive the input field element as the first argument,\n *   and a boolean indicating the validation result as the second argument.\n *   On completion of validation (when every element has been validated), \n *   the function will be invoked with either \n *      - the form element (if any), or \n *      - the SmartFormValidator instance\n *   and the result of the entire validation, \n *   that is, whether all fields are valid (true) or not (false).\n * @return {Object} with a `valid()` method. The method returns:\n *   true if all fields are valid according to supplied rules, false otherwise.\n */\nmodule.exports = function validateFormFields(callback) {\n  let formValid = false;\n  const form = this.form || this; // when we are using SmartFormValidator instance for isolated elements without an underlying form element.\n  const fields = this.getFields();\n  const inputFields = fields.filter(f => !(isSubmitButton(f)));\n  const submitButton = fields.find(isSubmitButton)?.getElement();\n  const rules = inputFields.map(field => Boolean(field.getRule()));\n\n  const classEffects = this.constructor.getEffects(); // SmartForm and SmartFormValidator are the constructors\n  const instanceEffects = this.getEffects();\n  const effects = Object.assign({}, \n    classEffects.default, classEffects.addon, \n    instanceEffects.default, instanceEffects.addon\n  );\n  const effectFns = Object.values(effects);\n  const validationCallback = getValidationCallback();\n  \n  inputFields.forEach(function observeField(field) {\n    const input = field.getElement();\n  \n    input.addEventListener(getListenerEvent(input), getChangeProcessor(field, input));\n  });\n  \n  return {\n    valid: () => formValid,\n  };\n\n  /**\n   * @param {Object} field: SmartField instance\n   * @param {Object} input: the underlying HTML Element of the SmartField instance \n   * @returns {Function} an event listener function\n   */\n  function getChangeProcessor(field, input) {\n    return function processInputChange() {\n      const valid = field.validate();\n      const validationState = validationCallback(field, valid, rules);\n\n      formValid = validationState.formValid;\n\n      if(typeof callback === \"function\") {\n        callback(input, valid);\n\n        if(validationState.allFieldsValidated) {\n          callback(form, formValid);\n        }\n      }\n\n      applyEffects(formValid, effectFns, submitButton);\n    };\n  }\n};\n\n\n// Helpers\nfunction applyEffects(validationPassed, effects, submitButton) {\n  if(effects.length === 0) {\n    throw new TypeError(errorMessages.noEffectsActive);\n  }\n\n  effects.forEach(({ valid, invalid }) => {\n    if(validationPassed) {\n      valid(submitButton);\n    } else {\n      invalid(submitButton);\n    }\n  });\n}\n\nfunction isSubmitButton(smartField) {\n  return smartField.role === \"submit-button\";\n}\n\n/**\n * Get the event we should listen for on an element.\n * @param {Object} input: HTML (input) element\n * @return {Object} the event to listen for on the element\n */\nfunction getListenerEvent(input) {\n  let targetEvent;\n\n  switch(input.type) {\n  case \"checkbox\" : targetEvent = \"click\"; break;\n  case \"email\"    :\n  case \"password\" : \n  case \"text\"     : \n  default         : targetEvent = \"input\"; break;\n  }\n\n  return targetEvent;\n}\n\n/**\n * @param void \n * @returns function. \n * The returned function takes and returns the following parameters and return value: \n *    @param {Object} field: SmartField instance\n *    @param {Boolean} valid: whether the current field passed validation or not\n *    @param {Array} rules: Array of the all the rules for all the fields being validated, not just for the current field.\n *    @returns {Object}\n */\nfunction getValidationCallback() {\n  let validatedFields = {};\n\n  return function validationCallback(field, valid, rules) {\n    let formValid = false;\n    let allFieldsValidated = false;\n\n    validatedFields[field.id] = validatedFields[field.id] || {};\n    validatedFields[field.id].valid = valid;\n  \n    if(Object.keys(validatedFields).length === rules.length) {\n      allFieldsValidated = true;\n      formValid = Object.values(validatedFields).every(field => field.valid);\n    }\n  \n    return { formValid, allFieldsValidated };\n  };\n}\n","const errorMessages = require(\"../error-messages\");\nconst { createListFromArray } = require(\"../helpers\");\n\nconst instanceMethodNames = [\n  \"addField\",\n  \"addFields\",\n  \"addRule\",\n  \"addValidator\", \n  \"getValidators\",\n  \"getEffects\",\n  \"getField\",\n  \"getFields\",\n  \"removeRule\",\n  \"toJSON\",\n  \"useEffect\",\n  \"validate\",\n  \"watch\",\n];\n\nconst staticMethodNames = [\"getEffects\", \"useEffect\"];\n\nmodule.exports = { \n  addInstanceMethod,\n  addStaticMethod,\n};\n\n\n/**\n * \n * @param {Function} ctor: a constructor function \n * @param {String} methodName: the method name to bind to instances of that constructor\n */\nfunction addInstanceMethod(ctor, methodName) {\n  if(typeof ctor !== \"function\") {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"ctor\")\n        .replace(\":type:\", \"(constructor) function\")\n    );\n  }\n\n  if(!instanceMethodNames.includes(methodName)) {\n    throw new TypeError(\n      errorMessages.unknownType\n        .replace(\":type:\", \"instance method\")\n        .replace(\":typeName:\", methodName)\n        .replace(\":types:\", \"methods\")\n        .replace(\":allowedTypes:\", createListFromArray(instanceMethodNames))\n    );\n  }\n\n  ctor.prototype[methodName] = require(`./${methodName}`);\n}\n\n/**\n * \n * @param {Function} ctor: a constructor function \n * @param {String} methodName: the method name to bind as a static member to the constructor\n */\nfunction addStaticMethod(ctor, methodName) {\n  if(typeof ctor !== \"function\") {\n    throw new TypeError(\n      errorMessages.functionParamExpectsType\n        .replace(\":param:\", \"ctor\")\n        .replace(\":type:\", \"(constructor) function\")\n    );\n  }\n  \n  if(!staticMethodNames.includes(methodName)) {\n    throw new TypeError(\n      errorMessages.unknownType\n        .replace(\":type:\", \"static method\")\n        .replace(\":typeName:\", methodName)\n        .replace(\":types:\", \"methods\")\n        .replace(\":allowedTypes:\", createListFromArray(staticMethodNames))\n    );\n  }\n  \n  ctor[methodName] = require(`./${methodName}`);\n}","\"use strict\";\n\nconst errorMessages = require(\"./error-messages\");\nconst { is, isSubmitBtn, validateId } = require(\"./helpers\");\nconst { addInstanceMethod, addStaticMethod } = require(\"./methods\");\n\nconst staticMethods = [\"getEffects\", \"useEffect\"];\nconst instanceMethods = [\n  \"addRule\", \"removeRule\", \"getField\", \"getFields\", \n  \"getEffects\", \"useEffect\", \"toJSON\", \"validate\", \"watch\"\n];\n\n\nmodule.exports = SmartForm;\n\n\n/**\n * Create a new SmartForm object.\n * @param {Object|String} the form element to add validation routine to.\n *    This can be the HTML form object if we already have it, or its ID.\n * @param {Array} rules (optional): array of objects specifying the validation rules for the form's elements.\n * @param {String} [rules[i].fieldId]: the id of the input field to apply these rules to\n * @param {Boolean} [rules[i].required]: specifies whether the field is required (true) or not (false)\n * @param {Number|Object} [rules[i].length]: specifies the accepted input length. \n *    If the value is a number, it specifies the maximum length.\n *    If the value is an object, it specifies. the minimum and/or maximum length.\n * @param {Number} [rules[i].length.min]: specifies the mininum accepted input length\n * @param {Number} [rules[i].length.max]: specifies the maximum accepted input length\n * @param {Boolean} [rules[i].matchCase]: performs a case-sensitive (true) or case-insensitive (false) validation.\n * @param {String} [rules[i].type]: the input field's expected data type (alnum|alpha|email|number|text).\n *    Default is alnum.\n * @param {String} [rules[i].regex]: specifies a custom validation regex.\n * \n * @returns this.\n * \n * Before any of the form's fields can have any validation performed on them, \n * a rule must be added to it\n * either during initialization or by calling the addRule(rule) method on the SmartForm instance.\n */\nfunction SmartForm(form, rules) {\n  if(typeof form === \"string\") {\n    form = document.getElementById(form.trim());\n  }\n\n  if(!is.object(form)) {\n    throw new TypeError(\n      errorMessages.htmlElementExpected\n        .replace(\":param:\", \"form\")\n        .replace(\":elementType:\", \"form\")\n    );\n  }\n\n  this.form = form;\n  this.fields = [];\n  const elements = form.elements;\n\n  if(elements) {\n    Array.from(elements).forEach(input => {\n      if(validateId(input.id) || isSubmitBtn(input)) {\n        this.addField(input);\n      }\n    });\n  }\n  \n  if(is.array(rules)) {\n    // Grab a hold of only the input fields passed to our smart-form-validator processor; \n    // Ignore other fields and let the user handle those themselves.\n    rules.forEach(rule => {\n      const input = form.querySelector(`#${rule.fieldId}`);\n\n      if(input && this.getField(input.id)) {\n        this.addRule(rule);\n      }\n    });\n  }\n}\n\nSmartForm.prototype.addField = function addField(element, rule) {\n  const formInputIds = Array.from(this.form.elements).map(el => el.id);\n\n  if(formInputIds.includes(element.id)) {\n    require(\"./methods/addField\").call(this, element, rule);\n  }\n\n  return this;\n};\n\nstaticMethods.forEach(function bindMethodToClass(method) {\n  addStaticMethod(SmartForm, method);\n});\n\ninstanceMethods.forEach(function bindMethodToInstance(method) {\n  addInstanceMethod(SmartForm, method);\n});\n","\"use strict\";\n\nconst { addInstanceMethod, addStaticMethod } = require(\"./methods\");\nconst SmartForm = require(\"./smart-form\");\n\nconst staticMethods = [\"getEffects\", \"useEffect\"];\nconst instanceMethods = [\n  \"addField\", \"addFields\", \"addRule\", \"removeRule\", \"addValidator\", \"getValidators\", \n  \"getField\", \"getFields\", \"getEffects\", \"useEffect\", \"toJSON\", \"validate\", \"watch\"\n];\n\n\nmodule.exports = SmartFormValidator;\n\n\nfunction SmartFormValidator() { \n  this.fields = [];\n  this.form = null;\n}\n\n/**\n * Create a new SmartForm object.\n * @param {Object|String} the HTML form element to add validation routine to.\n *    This can be the HTML form object if we already have it, or its ID.\n * @param {Array} rules (optional): array of objects specifying the validation rules for the form's elements.\n * @param {String} [rules[i].fieldId]: the id of the input field to apply these rules to\n * @param {Boolean} [rules[i].required]: specifies whether the field is required (true) or not (false)\n * @param {Number|Object} [rules[i].length]: specifies the accepted input length. \n *    If the value is a number, it specifies the maximum length.\n *    If the value is an object, it specifies. the minimum and/or maximum length.\n * @param {Number} [rules[i].length.min]: specifies the mininum accepted input length\n * @param {Number} [rules[i].length.max]: specifies the maximum accepted input length\n * @param {Boolean} [rules[i].matchCase]: performs a case-sensitive (true) or case-insensitive (false) validation.\n * @param {String} [rules[i].type]: the input field's expected data type (alnum|alpha|email|number|text).\n *    Default is alnum.\n * @param {String} [rules[i].regex]: specifies a custom validation regex.\n * \n * @returns {Object} SmartForm instance.\n * \n * Before any of the form's fields can have any validation performed on them, \n * a rule must be added to it\n * either here or by calling the addRule(rule) method on the returned SmartForm instance.\n */\nSmartFormValidator.prototype.addForm = function addForm(form, rules) {\n  const smartForm = new SmartForm(form, rules);\n\n  this.form = smartForm.form;\n\n  return smartForm;\n};\n\nstaticMethods.forEach(function bindMethodToClass(method) {\n  addStaticMethod(SmartFormValidator, method);\n});\n\ninstanceMethods.forEach(function bindMethodToInstance(method) {\n  addInstanceMethod(SmartFormValidator, method);\n});\n","\"use strict\";\n\nconst SmartFormValidator = require(\"./smart-form-validator\");\n\nmodule.exports = SmartFormValidator;\n"],"names":["errorMessages","argNamesAreReserved","fieldCannotBeEmpty","fieldNotRegistered","functionParamExpectsType","functionParamIsRequired","htmlElementExpected","noObjectWithSpecifiedKey","noEffectsActive","noValidatorsActive","objectPropertyCannotBeEmpty","objectMustHaveProperty","objectsMustHaveProperty","objectPropertyShouldHaveType","objectWithKeyExists","objectWithKeyExistsCanReplace","unknownType","require$$0","is","array","isArray","function","data","number","num","Number","isNaN","object","isObject","string","helpers","clone","cloneAndExtend","obj","newProps","Object","assign","has","prop","prototype","hasOwnProperty","call","createListFromArray","generateEffectName","getEffectNames","effects","effectObjects","values","map","effect","name","getValidatorNames","validators","keys","isSubmitBtn","element","type","role","normalizeId","id","String","trim","preEffectRegistrationCheck","defaultEffectNames","TypeError","replace","meta","valid","invalid","namespace","effectName","length","includes","_objectSpread","preValidatorRegistrationCheck","validatorKey","validatorFn","validatorMeta","defaultValidatorKeys","validatorNamespace","generateValidatorKey","validateId","_typeof","Boolean","APP_CLASSNAME","DISABLED_FIELD_CLASSNAME","SMART_FIELD_CLASSNAME","VALID_FIELD_CLASSNAME","INVALID_FIELD_CLASSNAME","Array","combinator","concat","join","key","effectsHelpers","isSubmitButton","require$$1","addBottomBorder","field","classList","remove","add","addValidationStatusIcons","canSubmitForm","validationPassed","input","submitBtn","removeAttribute","setAttribute","e","console","log","message","toggleSubmitButton","init","require$$2","regexRules","getLengthRegex","lengthRule","regexStr","len","min","max","tmp","getRegexRules","matchCase","validatorHelpers","createAlphanumericRegexObject","rule","emptyLengthCharacter","lenRegex","RegExp","alphanumericValidator","value","allowWhitespace","test","alphaValidator","asciiTextValidator","regex","emailValidator","emailParts","split","_emailParts","_slicedToArray","account","address","some","part","lengthValidator","numberValidator","regexValidator","require$$3","require$$4","require$$5","require$$6","requiredFieldValidator","_","extras","required","checked","defaultValidators","defaultEffects","defaultValidatorFunctions","entries","SmartField","getValue","this","Map","_step","_input$classList","_input$classList2","_iterator","_createForOfIteratorHelper","s","n","done","set","err","f","addRule","fieldId","smartField","existingRule","removeRule","getRule","getEffect","toLowerCase","get","getEffects","default","addon","useEffect","parsedEffect","usesEffect","getElement","size","addValidator","hasValidator","getValidators","_input$type","_input$tagName","selectElement","tagName","_getHtmlSelectElement","text","options","selectedIndex","isContentEditable","textContent","validate","_this$getValidators","addonValidators","from","_this$getEffects","addonEffects","reduce","passed","fn","forEach","_ref","watch","callback","targetEvent","_this","addEventListener","addField","document","getElementById","getField","fields","push","addFields","getFields","_i","_Object$values","find","_Object$entries","_Object$entries$_i","validator","toJSON","_effect$meta","every","_fields$find","validatedFields","formValid","form","inputFields","filter","submitButton","rules","classEffects","constructor","instanceEffects","effectFns","validationCallback","allFieldsValidated","getListenerEvent","validationState","applyEffects","getChangeProcessor","instanceMethodNames","staticMethodNames","methods","ctor","methodName","require","addInstanceMethod","addStaticMethod","smartForm","SmartForm","elements","querySelector","SmartForm$1","el","method","smartFormValidator","SmartFormValidator","SmartFormValidator$1","addForm"],"mappings":"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"}